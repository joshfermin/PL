PEP: 227 - Statically Nested Scopes
====
### Louis Bouddhou, Alex Campbell, Josh Fermin










































<!-- JOSH - PART -->

Discussion
==========
As described by the python enhancement proposal, “the specified rules [from the PEP] allow names defined in a function to be referenced in any nested function defined with that function” (https://www.python.org/dev/peps/pep-0227/). The python language follows these rules except for the following cases: Names in class scope, the use of the global statement, and variables not declared. Only the first two cases will be described in this paper.

The names in a class scope are omitted from the rules to prevent inconsistent behaviors when accessing class attributes and local variables. Take for example the following code:

```python
my_var = 'global'
class MyClass(object):
   my_var = 'class' 
   def __init__(self):
      print my_var #global
      print MyClass.my_var #class
      print self.my_var #class -- Only since we haven't set this attribute on the instance
      self.my_var = 'instance' #set instance attribute.
      print self.my_var #instance
      print MyClass.my_var #class
```
In this code it can be inferred that there is a naming conflict of 
my_var between the global scope and the class scope MyClass. To solve this “you can get access to it via MyClass.my_var or as self.my_var from within the class (provided you don't create an instance variable with the same name)” (http://stackoverflow.com/questions/12941748/python-variable-scope-and-classes). This PEP ignores the statically nested scope and instead will try to resolve the name in the innermost nested function. The names in the class scope are not directly accessible without the use of the self or MyClass keyword. The main reason for not allowing name bindings in class scope is because this would allow class attributes be referenced by either their simple name or the attribute reference. Allowing the simple names would make the code difficult to read and understand which variable is which. 

The other exception to the rules of the statically nested scopes is the global statement. This global statement retains “the same effect that it does for Python 2.0” (https://www.python.org/dev/peps/pep-0227/). To describe the reasoning behind this see the example below: 

``` python
myvariable = 5
def func():
    global myvariable
    myvariable = 6   #changes global scope
    print myvariable #prints 6

func()
print myvariable  #prints 6
```
> Example from: http://stackoverflow.com/questions/13881395/in-python-what-is-a-global-statement

When using the declaration “global” the name that was declared now only refers to the binding in the global module namespace instead of the local binding namespace. Therefore in statically nested functions, anything that is declared with the global keyword does not refer to the whole function scope but instead to the global namespace.


Backwards Compatibility
==================
In terms of backwards compatibility there are two obvious problems caused by this new change. The first being different code behaviors (as seen in examples before) and then code giving syntax errors upon compilation from before and after the change. To reinforce the idea of the code behavior problem, take the following example:

```python 
 x = 1
    def f1():
        x = 2
        def inner():
            print x
        inner()
```
> Example from: https://www.python.org/dev/peps/pep-0227/

Before the changes in this PEP, this function would print 1 because the inner scope of function inner() would not inherit the scope the function f1(). After this change the function now prints 2 because it will inherit the scope of the f1() function thus changing the behavior of the code.

In terms of syntax errors being caused by the changes made in this PEP observe the following chunk of code:

```python
y = 1
def f():
    exec "y = 'gotcha'" # or from module import *
    def g():
        return y
```
> Example from: https://www.python.org/dev/peps/pep-0227/

After this change is implemented, during compile-time, the compiler will not be able to distinguish in g() if “y” refers to the global scoped “y” or the local scope “y” in the function f(). Therefore this will throw a compile time error because the compiler will not know which “y” to use in the function g. 

Conclusion
========
The changes introduced in this PEP are very beneficial to the languages as best seen in the bank account example. Without this change, to implement the bank account nested function 
would require a lot of workarounds such as implementing a class to allow for the scope to work. And even though nested scopes aren’t as common and multi level nested scopes even less common, allowing these scopes to inherit the parent functions helps with intuitively understanding how variables are transferred. 
